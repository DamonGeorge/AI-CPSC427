import java.util.ArrayList;

/**
 * A state in the Othello state space.
 * This holds the current board, the previous move that 
 * arrived at this board, whose turn it is, the children, and the hash. 
 */
public class OthelloNode {
	
	//***************************************************
	//Static Variables
	//***************************************************
	//stability constants
	private static final int STABLE = 1;
	private static final int UNSTABLE = -1;
	private static final int SEMI_STABLE = 0;
	
	//weighting for all the heuristics we calculate
	//Order: count, mobility, stable, unstable, semi-stable, corners, potential corners
	public static final double[] HEURISTIC_WEIGHTS = {0.05, 0.15, 0.3, -0.1, 0.1, 0.3, 0.2};
	
	//***************************************************
	//Instance Variables
	//***************************************************
	private char[][] board;
	private OthelloMove previousMove;
	private boolean isBlacksMove;
	private ArrayList<OthelloNode> children;
	private int zobristHash;
	private Integer score;
	
	//***************************************************
	//Instance Functions
	//***************************************************
	
	//overloaded constructors
	public OthelloNode(char[][] board, boolean isBlacksMove, int zobristHash) {
		this(board, isBlacksMove, zobristHash, null);
	}
	public OthelloNode(char[][] board, boolean isBlacksMove, int zobristHash, int previousMoveRow, int previousMoveCol) {
		this(board, isBlacksMove, zobristHash, new OthelloMove(previousMoveRow, previousMoveCol));
	}

	/**
	 * Main constructor. This creates the node from the given board,
	 * whose turn it is, the hash, and the previous move.
	 */
	public OthelloNode(char[][] board, boolean isBlacksMove, int zobristHash, OthelloMove previousMove) {
		this.board = board;
		this.isBlacksMove = isBlacksMove;
		this.previousMove = previousMove;
		this.zobristHash = zobristHash;
		
		//initialize to null
		this.children = null;
		this.score = null;
	}

	//Getters
	public char[][] getBoard() {
		return board;
	}
	public ArrayList<OthelloNode> getChildren() {
		return children;
	}
	public OthelloMove getPreviousMove() {
		return previousMove;
	}
	public boolean isBlacksMove() {
		return isBlacksMove;
	}
	public int getZobristHash() {
		return zobristHash;
	}
	
	//setters
	public void setChildren(ArrayList<OthelloNode> children) {
		this.children = children;
	}
	
	
	//heuristic evaluation functions:
	
	/**
	 * Get the score for a leaf node. This score is the difference 
	 * between the AI's score and the player's score multiplied by 1000
	 * so as to make the score better or worse than the values generated by the heuristic calculation.
	 */
	public int getLeafScore(boolean isAIBlack) {
		if(this.score == null) {
			int whiteScore = 0;
			int blackScore = 0;
			
			for(int i = 0; i < board.length; i++) {
	        	for(int j = 0; j < board[0].length; j++) {
	        		if(this.board[i][j] == OthelloGame.BLACK) blackScore++;
	        		else if (this.board[i][j] == OthelloGame.WHITE) whiteScore++;
	        	}
	        }
			if(isAIBlack)
				this.score = blackScore - whiteScore;
			else
				this.score = whiteScore - blackScore;
		}
		
		return this.score * 1000; //multiply to make value larger/smaller than heuristic values
	}
	
	/**
	 * This is the heuristic for a node in the Othello state space.
	 * This calculates 7 different heuristics and then uses the weights defined
	 * statically in this class to combine them into a single double value.
	 * 
	 * The heuristics calculated: (these are calculated as a normalized difference between the two players)
	 * 		count:	The difference in score
	 * 		mobility: The difference in the number of legal moves for each player
	 * 		stable:	The difference in the number of stable (unflippable) tokens
	 * 		unstable: The difference in the number of unstable (immediately flippable) tokens
	 * 		semi-stable: The difference in the number of semi-stable(not currently flippable) tokens
	 * 		corners: The difference in the number of corners held
	 * 		potential corners: the difference in the number of corners that could be taken immediately
	 * 
	 * 
	 */
	public double calculateFullHeuristic(boolean isPlayerBlack) {
		//for count heuristic
		int whiteScore = 0;
		int blackScore = 0;
		
		//for actual mobility
		int numLegalMovesBlack = 0;
		int numLegalMovesWhite = 0;
		
		//for stability
		int numStableWhite = 0;
		int numUnstableWhite = 0;
		int numSemiStableWhite = 0;
		int numStableBlack = 0;
		int numUnstableBlack = 0;
		int numSemiStableBlack = 0;
		
		//for corners
		int numCornersWhite = 0;
		int numPotentialCornersWhite = 0;
		int numCornersBlack = 0;
		int numPotentialCornersBlack = 0;
		
		for(int i = 0; i < board.length; i++) {
			for(int j = 0; j < board[0].length; j++) {
				if(board[i][j] == OthelloGame.EMPTY) { //calculate mobility
					if(OthelloGame.isValidMove(board, i, j, true)) numLegalMovesBlack++;
					if(OthelloGame.isValidMove(board, i, j, false)) numLegalMovesWhite++;
					
					
				}else if(board[i][j] == OthelloGame.BLACK) {
					blackScore++; //for count heuristic
					
					//for stability heuristic
					int stability = getStability(i, j);
					if(stability == STABLE) numStableBlack++;
					else if(stability == UNSTABLE) numUnstableBlack++;
					else numSemiStableBlack++;
					
					
				}else {
					whiteScore++; //for count heuristic
					
					//for stability heuristic
					int stability = getStability(i, j);
					if(stability == STABLE) numStableWhite++;
					else if(stability == UNSTABLE) numUnstableWhite++;
					else numSemiStableWhite++;
					
				}
			}
		}
		
		//if this is a leaf node
		if(numLegalMovesBlack == 0 && numLegalMovesWhite == 0) {
			return getLeafScore(isPlayerBlack); //TODO: don't we need to know whether the AI is black or not to do this right?
		}
		
		
		//handle corners
		int[] cornerRow = {0, 0, OthelloGame.BOARD_SIZE-1, OthelloGame.BOARD_SIZE-1};
		int[] cornerCol = {0, OthelloGame.BOARD_SIZE-1, 0, OthelloGame.BOARD_SIZE-1};
		
		//loop corners
		for(int i = 0; i < 4; i++) {
			if(board[cornerRow[i]][cornerCol[i]] == OthelloGame.BLACK) {
				numCornersBlack++;
			}
			else if (board[cornerRow[i]][cornerCol[i]] == OthelloGame.WHITE) {
				numCornersWhite++;
			}
			else {
				if(OthelloGame.isValidMove(board, cornerRow[i], cornerCol[i], true))
					numPotentialCornersBlack++;
				if(OthelloGame.isValidMove(board, cornerRow[i], cornerCol[i], false))
					numPotentialCornersWhite++;
			}
		}
		
		//heuristic values
		double countHeuristic = calculateHeuristicValue(blackScore, whiteScore, isPlayerBlack);
		double actualMobilityHeuristic = calculateHeuristicValue(numLegalMovesBlack, numLegalMovesWhite, isPlayerBlack);
		double stableHeuristic = calculateHeuristicValue(numStableBlack, numStableWhite, isPlayerBlack);
		double unstableHeuristic = calculateHeuristicValue(numUnstableBlack, numUnstableWhite, isPlayerBlack);
		double semiStableHeuristic = calculateHeuristicValue(numSemiStableBlack, numSemiStableWhite, isPlayerBlack);
		double cornersHeuristic = calculateHeuristicValue(numCornersBlack, numCornersWhite, isPlayerBlack);
		double potentialCornersHeuristic = calculateHeuristicValue(numPotentialCornersBlack, numPotentialCornersWhite, isPlayerBlack);
		
		//calculate final value
		return countHeuristic*HEURISTIC_WEIGHTS[0] + actualMobilityHeuristic*HEURISTIC_WEIGHTS[1] 
				+ stableHeuristic*HEURISTIC_WEIGHTS[2] + unstableHeuristic*HEURISTIC_WEIGHTS[3] + semiStableHeuristic*HEURISTIC_WEIGHTS[4] 
				+ cornersHeuristic*HEURISTIC_WEIGHTS[5]+ potentialCornersHeuristic*HEURISTIC_WEIGHTS[6];
	}
	
	/**
	 * This is used by the heuristic calculations to normalize the difference between
	 * a value calculated for both players. The value is calculated relative to the
	 * current player.
	 */
	public double calculateHeuristicValue(int blacksValue, int whitesValue, boolean isPlayerBlack) {
		int diff = isPlayerBlack ? blacksValue - whitesValue : whitesValue - blacksValue;
		
		int sum = blacksValue + whitesValue;
		
		if(sum != 0)
			return diff/sum;
		else
			return 0.0;
	}
	
	/**
	 * Get the stability for the given space on the board.
	 * This returns either Stable, Unstable, or SemiStable,
	 * and is actually pretty difficult to calculate.
	 * 
	 * This loops through each of the four directions of moves (up, down and diagonals).
	 * For each direction, it checks one side of the current space for a possible move 
	 * by the other player. Then it checks the other side. Depending on the moves possible
	 * by the other player, the token is either unflippable, currently flippable, or possibly
	 * flippable in the future. 
	 */
	public int getStability(int row, int col) {
		boolean isBlacksMove =  board[row][col] == OthelloGame.BLACK;
		char opposingColor = isBlacksMove ? OthelloGame.WHITE : OthelloGame.BLACK;
		
		int[] deltaRow = {0, 1, 1, -1};
		int[] deltaCol = {1, 0, 1, 1};
		
		int currentRow = row;
		int currentCol = col;
		
		boolean isSemiStable = false;
		
		//loop through each direction
		for(int i = 0; i < 4; i++) {
			boolean firstSideHasOpposingColor = false;
			boolean firstSideHasPossibleMove = false;
			boolean firstSideHasOpenSpace = false;
			boolean secondSideHasOpposingColor = false;
			boolean secondSideHasPossibleMove = false;
			boolean secondSideHasOpenSpace = false;
			
			//first side
			currentRow = row - deltaRow[i];
			currentCol = col - deltaCol[i];
			
			while(OthelloGame.isValidPosition(currentRow, currentCol)) {
				if(board[currentRow][currentCol] == opposingColor) {
					firstSideHasOpposingColor = true;
					break;
				} else if(board[currentRow][currentCol] == OthelloGame.EMPTY) {
					if(OthelloGame.isValidMove(board, currentRow, currentCol, !isBlacksMove)) {
						firstSideHasPossibleMove = true;
					} else {
						firstSideHasOpenSpace = true;
					}
					break;
				}
				
				currentRow -= deltaRow[i];
				currentCol -= deltaCol[i];
			}
			
			if(!firstSideHasOpposingColor && !firstSideHasPossibleMove && !firstSideHasOpenSpace) {
				continue; //no flip possible in this direction
			}else {
				//second side
				currentRow = row + deltaRow[i];
				currentCol = col + deltaCol[i];
				
				while(OthelloGame.isValidPosition(currentRow, currentCol)) {
					if(board[currentRow][currentCol] == opposingColor) {
						secondSideHasOpposingColor = true;
						break;
					}else if(board[currentRow][currentCol] == OthelloGame.EMPTY) {
						if(OthelloGame.isValidMove(board, currentRow, currentCol, !isBlacksMove)) {
							secondSideHasPossibleMove = true;
						} else {
							secondSideHasOpenSpace = true;
						}
						break;
					}
					
					currentRow += deltaRow[i];
					currentCol += deltaCol[i];
				}
			}
			if(!secondSideHasOpposingColor && !secondSideHasPossibleMove && !secondSideHasOpenSpace) {
				continue; //no flip possible in this direction
			}
			else if ((firstSideHasOpposingColor && secondSideHasPossibleMove) ||
					(secondSideHasOpposingColor && firstSideHasPossibleMove)) {
				return UNSTABLE;
			}
			else if ((firstSideHasPossibleMove || firstSideHasOpenSpace)
					&& (secondSideHasPossibleMove || secondSideHasOpenSpace)) {
				isSemiStable = true;
			}
		}
		if(isSemiStable)
			return SEMI_STABLE;
		else
			return STABLE;
	}
	
	
	//Overridden functions
	
	//hashcode and equals are necessary for using this class as a key 
	//in the zobrist hashmap
	@Override
	public int hashCode() {
		return getZobristHash();
	}
	
	@Override
	public boolean equals(Object o) {
		//basic checks
		if (this == o)
            return true;
        if (o == null)
            return false;
        if (getClass() != o.getClass())
            return false;
        
        //check if boards are equal
        OthelloNode node = (OthelloNode) o;
        for(int i = 0; i < board.length; i++) {
        	for(int j = 0; j < board[0].length; j++) {
        		if(this.board[i][j] != node.board[i][j])
        			return false;
        	}
        }
        
        return true;
	}
	
	//This is useful for debugging and prints out the board and other info about the node
	@Override
	public String toString() {
		String value = 		"********** Othello Node **********\n";
		if(previousMove != null)
			value += String.format("Previous Move: %d, %d\n", previousMove.getRow(), previousMove.getCol());
		
		value +=  String.format("Is Black's Move: %b\n", isBlacksMove)
				+ String.format("Zobrist Hash: %d\n", zobristHash)
				+ "[\n";
		
		for(int i = 0; i < board.length; i++) {
			for(int j = 0; j < board[0].length; j++) {
				if(board[i][j] == OthelloGame.EMPTY)
					value += " , ";
				else 
					value += board[i][j] + ", ";
			}
			value += "\n";
		}
		
		value += "]\n";
		
		return value;
	}
 }